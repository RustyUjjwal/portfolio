{
    "solarTracker": {
        "title": "Automated Solar Tracking System",
        "files": {
            "solar-tracker.ino": {
        "lang": "arduino",
        "code": "#include <Servo.h>\n#include <LiquidCrystal.h>\n#include <DHT.h>\n\n#define TRACKING_MODE 2\n#define ENABLE_LCD true\n#define ENABLE_TEMP false\n#define DEBUG_MODE true\n\n#define LDR_TOP_LEFT A0\n#define LDR_TOP_RIGHT A1\n#define LDR_BOTTOM_LEFT A2\n#define LDR_BOTTOM_RIGHT A3\n\n#define SERVO_HORIZONTAL 9\n#define SERVO_VERTICAL 10\n#define EMERGENCY_STOP_PIN 8\n#define STATUS_LED_PIN 13\n\n#define LCD_RS 12\n#define LCD_ENABLE 11\n#define LCD_D4 5\n#define LCD_D5 4\n#define LCD_D6 3\n#define LCD_D7 2\n\n#define DHT_PIN 7\n\n#define TOLERANCE 25\n#define SERVO_STEP 2\n#define UPDATE_INTERVAL 500\n#define MOVEMENT_DELAY 100\n\n#define HORIZONTAL_MIN 0\n#define HORIZONTAL_MAX 180\n#define VERTICAL_MIN 0\n#define VERTICAL_MAX 180\n\n#define MAX_CONTINUOUS_MOVES 50\n#define NIGHT_MODE_THRESHOLD 50\n\nServo horizontalServo;\nServo verticalServo;\n\nint horizontalPos = 90;\nint verticalPos = 90;\n\nbool systemActive = true;\nbool manualMode = false;\nbool emergencyStop = false;\nbool isTracking = false;\nunsigned long lastUpdate = 0;\nunsigned long lastMovement = 0;\nint continuousMovements = 0;\n\nint ldrReadings[4] = {0, 0, 0, 0};\nint avgTop, avgBottom, avgLeft, avgRight;\n\n#if ENABLE_LCD\nLiquidCrystal lcd(LCD_RS, LCD_ENABLE, LCD_D4, LCD_D5, LCD_D6, LCD_D7);\n#endif\n\n#if ENABLE_TEMP\nDHT dht(DHT_PIN, DHT11);\nfloat temperature = 0;\nfloat humidity = 0;\n#endif\n\nvoid setup() {\n  Serial.begin(9600);\n  Serial.println(F(\"Solar Tracker v2.2 Initialized\"));\n  \n  pinMode(EMERGENCY_STOP_PIN, INPUT_PULLUP);\n  pinMode(STATUS_LED_PIN, OUTPUT);\n  digitalWrite(STATUS_LED_PIN, HIGH);\n  \n  horizontalServo.attach(SERVO_HORIZONTAL);\n  if (TRACKING_MODE == 2) {\n    verticalServo.attach(SERVO_VERTICAL);\n  }\n  \n  horizontalServo.write(horizontalPos);\n  if (TRACKING_MODE == 2) {\n    verticalServo.write(verticalPos);\n  }\n  \n  #if ENABLE_LCD\n  lcd.begin(16, 2);\n  lcd.print(F(\"Solar Tracker\"));\n  lcd.setCursor(0, 1);\n  lcd.print(F(\"Web Integrated\"));\n  delay(2000);\n  lcd.clear();\n  #endif\n  \n  #if ENABLE_TEMP\n  dht.begin();\n  #endif\n  \n  delay(1000);\n  lastUpdate = millis();\n}\n\nvoid loop() {\n  if (digitalRead(EMERGENCY_STOP_PIN) == LOW) {\n    if (!emergencyStop) {\n      emergencyStop = true;\n      handleEmergencyStop();\n    }\n    return;\n  } else {\n    emergencyStop = false;\n  }\n  \n  if (Serial.available()) {\n    handleSerialCommands();\n  }\n  \n  if (millis() - lastUpdate >= UPDATE_INTERVAL) {\n    readSensors();\n    \n    #if ENABLE_TEMP\n    readTemperature();\n    #endif\n    \n    checkDayNightMode();\n    \n    if (systemActive && !manualMode && !emergencyStop) {\n      performTracking();\n    }\n    \n    #if ENABLE_LCD\n    updateLCD();\n    #endif\n    \n    sendJSONData();\n    \n    lastUpdate = millis();\n    digitalWrite(STATUS_LED_PIN, !digitalRead(STATUS_LED_PIN));\n  }\n}\n\nvoid sendJSONData() {\n  String json = \"{\";\n  json += \"\\\"hPos\\\":\" + String(horizontalPos) + \",\";\n  json += \"\\\"vPos\\\":\" + String(verticalPos) + \",\";\n  json += \"\\\"ldr_tl\\\":\" + String(ldrReadings[0]) + \",\";\n  json += \"\\\"ldr_tr\\\":\" + String(ldrReadings[1]) + \",\";\n  json += \"\\\"ldr_bl\\\":\" + String(ldrReadings[2]) + \",\";\n  json += \"\\\"ldr_br\\\":\" + String(ldrReadings[3]) + \",\";\n  \n  #if ENABLE_TEMP\n  json += \"\\\"temp\\\":\" + String(temperature) + \",\";\n  #else\n  json += \"\\\"temp\\\":0,\";\n  #endif\n  \n  json += \"\\\"active\\\":\" + String(systemActive ? \"true\" : \"false\") + \",\";\n  json += \"\\\"manual\\\":\" + String(manualMode ? \"true\" : \"false\") + \",\";\n  json += \"\\\"tracking\\\":\" + String(isTracking ? \"true\" : \"false\");\n  json += \"}\";\n  \n  Serial.println(json);\n}\n\nvoid readSensors() {\n    ldrReadings[0] = analogRead(LDR_TOP_LEFT);\n    ldrReadings[1] = analogRead(LDR_TOP_RIGHT);\n    ldrReadings[2] = analogRead(LDR_BOTTOM_LEFT);\n    ldrReadings[3] = analogRead(LDR_BOTTOM_RIGHT);\n    \n    avgTop = (ldrReadings[0] + ldrReadings[1]) / 2;\n    avgBottom = (ldrReadings[2] + ldrReadings[3]) / 2;\n    avgLeft = (ldrReadings[0] + ldrReadings[2]) / 2;\n    avgRight = (ldrReadings[1] + ldrReadings[3]) / 2;\n}\n\n#if ENABLE_TEMP\nvoid readTemperature() {\n  temperature = dht.readTemperature();\n  humidity = dht.readHumidity();\n  if (isnan(temperature) || isnan(humidity)) {\n    temperature = 0;\n    humidity = 0;\n  }\n}\n#endif\n\nvoid checkDayNightMode() {\n  int totalLight = ldrReadings[0] + ldrReadings[1] + ldrReadings[2] + ldrReadings[3];\n  int avgLight = totalLight / 4;\n  \n  if (avgLight < NIGHT_MODE_THRESHOLD) {\n    if (systemActive) {\n      systemActive = false;\n      moveToRestPosition();\n    }\n  } else {\n    if (!systemActive) {\n      systemActive = true;\n    }\n  }\n}\n\nvoid performTracking() {\n  bool moved = false;\n  isTracking = false;\n  \n  int horizontalDiff = avgRight - avgLeft;\n  if (abs(horizontalDiff) > TOLERANCE) {\n    if (avgRight > avgLeft && horizontalPos > HORIZONTAL_MIN) {\n      horizontalPos -= SERVO_STEP;\n      moved = true;\n    } else if (avgLeft > avgRight && horizontalPos < HORIZONTAL_MAX) {\n      horizontalPos += SERVO_STEP;\n      moved = true;\n    }\n    if (moved) horizontalServo.write(horizontalPos);\n  }\n  \n  if (TRACKING_MODE == 2) {\n    int verticalDiff = avgTop - avgBottom;\n    if (abs(verticalDiff) > TOLERANCE) {\n      if (avgTop > avgBottom && verticalPos < VERTICAL_MAX) {\n        verticalPos += SERVO_STEP;\n        moved = true;\n      } else if (avgBottom > avgTop && verticalPos > VERTICAL_MIN) {\n        verticalPos -= SERVO_STEP;\n        moved = true;\n      }\n      if (moved) verticalServo.write(verticalPos);\n    }\n  }\n  \n  isTracking = moved;\n\n  if (moved) {\n    lastMovement = millis();\n    continuousMovements++;\n    if (continuousMovements >= MAX_CONTINUOUS_MOVES) {\n      delay(5000);\n      continuousMovements = 0;\n    }\n    delay(MOVEMENT_DELAY);\n  } else {\n    if (millis() - lastMovement > 10000) {\n      continuousMovements = 0;\n    }\n  }\n}\n\nvoid moveToRestPosition() {\n  horizontalPos = 90;\n  verticalPos = 45;\n  horizontalServo.write(horizontalPos);\n  if (TRACKING_MODE == 2) verticalServo.write(verticalPos);\n  delay(1000);\n}\n\n#if ENABLE_LCD\nvoid updateLCD() {\n  static unsigned long lastLCDUpdate = 0;\n  if (millis() - lastLCDUpdate < 2000) return;\n  \n  lcd.clear();\n  lcd.setCursor(0, 0);\n  lcd.print(F(\"H:\"));\n  lcd.print(horizontalPos);\n  if (TRACKING_MODE == 2) {\n    lcd.print(F(\" V:\"));\n    lcd.print(verticalPos);\n  }\n  \n  lcd.setCursor(12, 0);\n  if (!systemActive) lcd.print(F(\"SLEEP\"));\n  else if (manualMode) lcd.print(F(\"MAN\"));\n  else if (isTracking) lcd.print(F(\"TRACK\"));\n  else lcd.print(F(\"AUTO\"));\n  \n  lcd.setCursor(0, 1);\n  lcd.print(F(\"T:\"));\n  lcd.print(avgTop);\n  lcd.print(F(\" B:\"));\n  lcd.print(avgBottom);\n  \n  lastLCDUpdate = millis();\n}\n#endif\n\nvoid handleSerialCommands() {\n  String command = Serial.readStringUntil('\\n');\n  command.trim();\n  command.toUpperCase();\n  \n  if (command.startsWith(F(\"H\"))) {\n    if (manualMode) {\n      int angle = command.substring(1).toInt();\n      if (angle >= HORIZONTAL_MIN && angle <= HORIZONTAL_MAX) {\n        horizontalPos = angle;\n        horizontalServo.write(horizontalPos);\n      }\n    }\n  }\n  else if (command.startsWith(F(\"V\")) && TRACKING_MODE == 2) {\n    if (manualMode) {\n      int angle = command.substring(1).toInt();\n      if (angle >= VERTICAL_MIN && angle <= VERTICAL_MAX) {\n        verticalPos = angle;\n        verticalServo.write(verticalPos);\n      }\n    }\n  }\n  else if (command == F(\"AUTO\")) {\n    manualMode = false;\n  }\n  else if (command == F(\"MANUAL\")) {\n    manualMode = true;\n  }\n  else if (command == F(\"STOP\")) {\n    systemActive = false;\n  }\n  else if (command == F(\"START\")) {\n    systemActive = true;\n    manualMode = false;\n  }\n  else if (command == F(\"CENTER\")) {\n    horizontalPos = 90;\n    verticalPos = 90;\n    horizontalServo.write(horizontalPos);\n    if (TRACKING_MODE == 2) verticalServo.write(verticalPos);\n  }\n}\n\nvoid handleEmergencyStop() {\n  horizontalServo.detach();\n  if (TRACKING_MODE == 2) {\n    verticalServo.detach();\n  }\n  systemActive = false;\n  \n  Serial.println(F(\"{\\\"error\\\":\\\"EMERGENCY STOP ACTIVATED\\\"}\"));\n  \n  while(digitalRead(EMERGENCY_STOP_PIN) == LOW) {\n    digitalWrite(STATUS_LED_PIN, !digitalRead(STATUS_LED_PIN));\n    delay(100);\n  }\n\n  horizontalServo.attach(SERVO_HORIZONTAL);\n  if (TRACKING_MODE == 2) {\n    verticalServo.attach(SERVO_VERTICAL);\n  }\n  emergencyStop = false;\n  systemActive = true;\n  Serial.println(F(\"{\\\"status\\\":\\\"Emergency stop released\\\"}\"));\n}"
      }
        }
    },
    
    "iotWeather": {
        "title": "IoT Weather Monitoring Station",
        "files": {
            "STM32_Monitor.ino": {
        "lang": "arduino",
        "code": "#include <Wire.h>\n#include <Adafruit_BME280.h>\n#include <SoftwareSerial.h>\n#include <ArduinoJson.h>\n#include <EEPROM.h>\n\n#define ESP8266_TX PA9\n#define ESP8266_RX PA10\n#define LED_PIN PC13\n#define BUTTON_PIN PA0\n\n#define SEALEVELPRESSURE_HPA (1013.25)\n#define BME_SDA PB7\n#define BME_SCL PB6\n\n#define WIFI_SSID_MAX_LEN 32\n#define WIFI_PASS_MAX_LEN 64\n#define MQTT_SERVER_MAX_LEN 64\n#define DEVICE_ID \"STM32_001\"\n\n#define SENSOR_READ_INTERVAL 5000  \n#define MQTT_PUBLISH_INTERVAL 10000\n#define WIFI_RETRY_INTERVAL 30000 \n\nAdafruit_BME280 bme;\nSoftwareSerial esp8266(ESP8266_RX, ESP8266_TX);\n\nstruct SensorData {\n  float temperature;\n  float humidity;\n  float pressure;\n  unsigned long timestamp;\n  bool valid;\n};\n\nstruct WiFiConfig {\n  char ssid[WIFI_SSID_MAX_LEN];\n  char password[WIFI_PASS_MAX_LEN];\n  char mqtt_server[MQTT_SERVER_MAX_LEN];\n  int mqtt_port;\n  bool configured;\n  uint8_t checksum;\n};\n\nSensorData currentData;\nWiFiConfig wifiConfig;\nbool wifiConnected = false;\nbool mqttConnected = false;\nunsigned long lastSensorRead = 0;\nunsigned long lastMqttPublish = 0;\nunsigned long lastWifiRetry = 0;\nbool configMode = false;\n\nvoid setup() {\n  Serial.begin(115200);\n  esp8266.begin(115200);\n  pinMode(LED_PIN, OUTPUT);\n  pinMode(BUTTON_PIN, INPUT_PULLUP);\n\n  Serial.println(\"========================================\");\n  Serial.println(\"STM32 IoT Environmental Monitor v2.0\");\n  Serial.println(\"Device ID: \" + String(DEVICE_ID));\n  Serial.println(\"========================================\");\n\n  loadWiFiConfig();\n  if (digitalRead(BUTTON_PIN) == LOW) {\n    enterConfigMode();\n  }\n\n  if (!initializeSensors()) {\n    Serial.println(\"Sensor initialization failed!\");\n    blinkLED(5, 200);\n  } else {\n    Serial.println(\"Sensors initialized successfully\");\n  }\n\n  if (!initializeWiFi()) {\n    Serial.println(\"WiFi initialization failed!\");\n    blinkLED(3, 500);\n  }\n\n  currentData = readSensors();\n  if (currentData.valid) {\n    Serial.println(\"Initial sensor reading successful\");\n    Serial.printf(\"Temperature: %.2f°C\\n\", currentData.temperature);\n    Serial.printf(\"Humidity: %.2f%%\\n\", currentData.humidity);\n    Serial.printf(\"Pressure: %.2f hPa\\n\", currentData.pressure);\n  }\n\n  Serial.println(\"System ready!\");\n  blinkLED(2, 100);\n}"
      },
      "ESP8266_Manager.ino": {
        "lang": "arduino",
        "code": "#include <ESP8266WiFi.h>\n#include <ESP8266WebServer.h>\n#include <WiFiManager.h>\n#include <ArduinoJson.h>\n#include <EEPROM.h>\n#include <PubSubClient.h>\n\n#define SERIAL_BAUD 115200\n#define CONFIG_AP_NAME \"STM32_IoT_Config\"\n#define CONFIG_AP_PASSWORD \"config123\"\n#define MQTT_BUFFER_SIZE 512\n#define CONFIG_TIMEOUT 180 // 3 minutes\n\n#define LED_PIN 2\n#define RESET_PIN 0\n\nWiFiManager wifiManager;\nESP8266WebServer server(80);\nWiFiClient wifiClient;\nPubSubClient mqttClient(wifiClient);\n\nstruct Config {\n  char mqtt_server[64];\n  int mqtt_port;\n  char mqtt_user[32];\n  char mqtt_password[64];\n  char device_id[32];\n  bool configured;\n  uint8_t checksum;\n};\n\nConfig config;\nbool mqttConnected = false;\nunsigned long lastMqttAttempt = 0;\nconst unsigned long mqttRetryInterval = 30000;\n\nvoid setup() {\n  Serial.begin(SERIAL_BAUD);\n  EEPROM.begin(512);\n\n  pinMode(LED_PIN, OUTPUT);\n  pinMode(RESET_PIN, INPUT_PULLUP);\n\n  digitalWrite(LED_PIN, HIGH);\n\n  Serial.println(\"\\n========================================\");\n  Serial.println(\"ESP8266 WiFi Manager for STM32 IoT\");\n  Serial.println(\"Version: 2.0\");\n  Serial.println(\"========================================\");\n\n  loadConfig();\n  if (digitalRead(RESET_PIN) == LOW) {\n    Serial.println(\"Reset button pressed - clearing WiFi config\");\n    wifiManager.resetSettings();\n    delay(1000);\n  }\n}"
      },
      "iot_broker.py": {
        "lang": "python",
        "code": "#!/usr/bin/env python3\n\nimport paho.mqtt.client as mqtt\nimport json\nimport sqlite3\nimport datetime\nimport time\nimport threading\nimport logging\nimport os\nimport signal\nimport sys\nfrom typing import Dict, Any, List\nimport asyncio\nimport websockets\n\nMQTT_BROKER = \"localhost\"\nMQTT_PORT = 1883\nMQTT_USERNAME = None\nMQTT_PASSWORD = None\nWEBSOCKET_HOST = \"localhost\"\nWEBSOCKET_PORT = 8765\nDATABASE_PATH = \"iot_sensor_data.db\"\nLOG_FILE = \"iot_system.log\"\n\nSENSOR_DATA_TOPIC = \"sensors/+/data\"\nDEVICE_STATUS_TOPIC = \"sensors/+/status\"\n\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(levelname)s - %(message)s',\n    handlers=[\n        logging.FileHandler(LOG_FILE),\n        logging.StreamHandler(sys.stdout)\n    ]\n)\nlogger = logging.getLogger(__name__)\n\nCONNECTED_CLIENTS = set()\n\nasync def register_client(websocket):\n    CONNECTED_CLIENTS.add(websocket)\n    logger.info(f\"WebSocket client connected: {websocket.remote_address}\")\n    try:\n        await websocket.wait_closed()\n    finally:\n        CONNECTED_CLIENTS.remove(websocket)\n        logger.info(f\"WebSocket client disconnected: {websocket.remote_address}\")"
      },
      "config.h": {
        "lang": "c",
        "code": "// config.h - Centralized configuration for the project\n\n#ifndef CONFIG_H\n#define CONFIG_H\n\n// Hardware Configuration\n#define STM32_BOARD_TYPE \"STM32F103C8T6\"  // Blue Pill\n#define FIRMWARE_VERSION \"v2.1.3\"\n\n// Pin Definitions\n#define LED_BUILTIN_PIN PC13\n#define CONFIG_BUTTON_PIN PA0\n#define ESP8266_TX_PIN PA9\n#define ESP8266_RX_PIN PA10\n#define BME280_SDA_PIN PB7\n#define BME280_SCL_PIN PB6\n\n// Sensor Configuration\n#define BME280_I2C_ADDRESS_PRIMARY 0x76\n#define BME280_I2C_ADDRESS_SECONDARY 0x77\n#define SEALEVEL_PRESSURE_HPA 1013.25\n\n// Timing Configuration (milliseconds)\n#define SENSOR_READ_INTERVAL 5000\n#define MQTT_PUBLISH_INTERVAL 10000\n#define WIFI_RETRY_INTERVAL 30000\n\n#endif"
      },
      "wifi_methods.c": {
        "lang": "c",
        "code": "#include \"main.h\"\n#include \"string.h\"\n#include \"stdio.h\"\n\ntypedef struct {\n    char ssid[32];\n    char password[64];\n    uint8_t security_type;\n    uint8_t is_configured;\n} WiFi_Config_t;\n\nWiFi_Config_t wifi_config;\n\nvoid ESP_Init_HardCoded(char *SSID, char *PASSWORD) {\n    char data[100];\n\n    HAL_UART_Transmit(&huart1, (uint8_t*)\"AT+RST\\r\\n\", 8, 1000);\n    HAL_Delay(2000);\n\n    HAL_UART_Transmit(&huart1, (uint8_t*)\"AT\\r\\n\", 4, 1000);\n    HAL_Delay(500);\n\n    HAL_UART_Transmit(&huart1, (uint8_t*)\"AT+CWMODE=1\\r\\n\", 13, 1000);\n    HAL_Delay(500);\n\n    sprintf(data, \"AT+CWJAP=\\\"%s\\\",\\\"%s\\\"\\r\\n\", SSID, PASSWORD);\n    HAL_UART_Transmit(&huart1, (uint8_t*)data, strlen(data), 5000);\n    HAL_Delay(5000);\n\n    HAL_UART_Transmit(&huart1, (uint8_t*)\"AT+CIFSR\\r\\n\", 10, 1000);\n    HAL_Delay(1000);\n\n    HAL_UART_Transmit(&huart1, (uint8_t*)\"AT+CIPMUX=1\\r\\n\", 13, 1000);\n    HAL_Delay(500);\n}"
      }
        }
    }
    
}